<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 无内鬼，写点东西</title>
    <link>https://shawling.github.io/posts/</link>
    <description>Recent content in Posts on 无内鬼，写点东西</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 24 Feb 2021 15:47:09 +0800</lastBuildDate><atom:link href="https://shawling.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符串匹配</title>
      <link>https://shawling.github.io/posts/string-matching-algorithm/</link>
      <pubDate>Wed, 24 Feb 2021 15:47:09 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/string-matching-algorithm/</guid>
      <description>BF算法
暴力破解，从头开始，逐一在主串中比对模式串的每个字符，直到匹配成功。O(n*m)
RK算法（RabinKarp）
设计一个哈希算法，将字符串映射为一个整型。将模式串与子串的O(m)复杂度的比较转换为整型之间的比较。
哈希算法例子
将只有小写字母的字符串看成一个26进制数，然后转换为10进制数，这样子不同字符串得到的10进制数都是完全不同的。没有哈希冲突。同时每个子串的哈希值可以通过上一个相邻子串的哈希值快速算出。求出全部哈希值O(n）
但是这种方法可能会导致整型溢出。
例子2
将每个字母的ascii码相加，这样子会哈希冲突，但只要最后再加多一个完整子串判断即可
将主串的所有子串（n-m+1条），计算哈希值，将模式串计算哈希值，逐条对比，直到匹配成功O(n)
golang中的实现
当模式串短于63，并且主串短于64时，使用BF暴力搜索。
当模式串与主串都比较长时，使用RK算法。计算哈希值时的运行时溢出，会截取32位长度
BM算法
Trie树（字典树）
将字符串拆为一个个字符，每个字符为一个节点。从根节点到红色节点的遍历路径就是字符串本身。
树的构建
树的子节点用能包含字符集长度的数组表示，直接用child[ascii]
表示
树的查询
从第一个字符节点开始查询，直到完全匹配并且为红色节点
问题
每个节点都需要保存一个字符集长度的指纹数组，远远超过本身表达的一个字节。同时，如果这个节点的子节点比较少，数组会有很大浪费
应对策略
 可以用有序数组等数据结构替换这个子节点数组，或者用哈希表（会有一定空间浪费） 对于只有一个子节点的节点，可以将它与子节点合并  应用场景
自动补全
敏感词过滤
http://www.360doc.com/content/19/1115/10/33405611_873305276.shtml
设字符串长度为n，将敏感词（个数为t）构建成一个trie树，设树高度为h，使用3指针法，查找到字符串所有敏感词复杂度为O(n*h)
若使用KMP精准匹配，查找所有单个敏感词复杂度为O(n+h)，查找到所有敏感词为O(t*(n+h))
AC自动机
ac自动机就是在trie树的基础上用了KMP算法的思想
Sunday算法
https://www.jianshu.com/p/2e6eb7386cd3
各种字符串匹配算法的使用场景与特点
BF
暴力匹配，适合主串和模式串都不太长的场景（比如小于64），O(m*n)
RK
需要设计好哈希算法，降低哈希冲突的概率。O(n)
KMP
通过优化BF过程中字符串移动的长度，是最常用的单模式串匹配算法。O(n+m)
Trie树
多模式串匹配算法，构建一个前缀树。可以用来智能提示，也适合公共前缀较多的多模匹配场景。O(n*len),len是模式串平均长度
AC自动机
trie树在KMP算法下的优化版本，适合大量文本中多模式串的查找，O(n)</description>
    </item>
    
    <item>
      <title>堆和堆的应用</title>
      <link>https://shawling.github.io/posts/heap/</link>
      <pubDate>Tue, 02 Feb 2021 18:56:36 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/heap/</guid>
      <description>是一个完全二叉树 堆中每个节点的值都大于等于（或小于等于）其左右子节点的值，分别对应大顶堆，小顶堆  因为完全二叉树适合用数组存储，所以堆通常放在一个数组中
堆的存储下标从1开始，方便计算（哨兵）。加入节点为i，左节点的地址为2i，右节点的位置为2i + 1
插入
由于性质1，堆的插入直接放在数组尾部。假设是大顶堆，如果插入值比父节点小，则直接计算地址交换，直到循环到根节点。
插入操作时间复杂度为O(logn)
这是从下往上的堆化方法
删除顶部元素
删除顶部节点后，拿最右侧节点填补，并拿取左右子节点的最大值进行交换，直到到达底部，这是从上往下的堆化方法
堆排序
建堆
使用从上往下的方法建堆，时间复杂度O(n)
排序
先建堆，然后逐个将顶部元素交换到最后，再堆化，可以得到一个最大值。循环整个数组，可以得到排好序的数组。时间复杂度O(nlogn)
堆排序时间复杂度跟快排差不多，但是
 在遍历有序数组时，每次选择时内存不连续，无法很好用到cpu缓存 建堆的第一步会把数组打乱，对于相对有序的数据，增加了逆序度，变相增加了操作次数。而快排的操作次数不会多于逆序度  所以快排在排序方面比堆排序更常用
堆的其他应用
堆在排序时，没有快排好用。但是如果需要一个插入，取出性能稳定的有序数据集时，堆比较好用。
堆的插入，删除数据并堆化复杂度为O(logn)。如果是快排排序号的数组，插入复杂度为O(n) （二分查找到位置后再逐个后移元素插入），删除同理。所以堆的动态更新性能比已排序数组好。
优先队列类型
优先队列一般用堆来实现，插入数据，删除数据都是O(logn)
合并有序小文件（比如日志文件）
建立一个堆，节点数量等于文件数量k，从多个小文件中读取第一个数据进堆并堆化。然后从堆顶取出一个数据，同时从它所属的文件中再读取一个数据放到堆顶并堆化，复杂度O(logk)。总的复杂度O(nlogk)，需要的额外内存空间O(k)
计时器
求TOPK类型
求动态数据集的中位数
先将数据从小到大排序，将前半部分n/2或n/2+1放入大顶堆，将后半部分放入小顶堆。这样子两个堆头（偶数）或者大顶堆堆头（奇数）就是好数据集的中位数。
在有新数据时，先与大顶堆比较，如果小于等于堆头，则放入大顶堆，如果节点数超过一半，则删除堆头并放入小顶堆，维持两个堆规范。
这样子求动态数据集的中位数复杂度为O(1)，插入新数据复杂度为O(logn)
求百分位数据同理</description>
    </item>
    
    <item>
      <title>前K大的数</title>
      <link>https://shawling.github.io/posts/top-k/</link>
      <pubDate>Fri, 29 Jan 2021 16:04:48 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/top-k/</guid>
      <description>TOP K
从数组中找到最大的K的数
思路一：
将整个数组排序，使用快排，O(n*logn)
思路二：
K后面的元素排序无意义，可以去掉这个步骤。使用冒泡排序，每次选择最大的一个数浮上去，重复K次后，可以得到结果，O(n*k)
思路三：
K个元素的排序也无意义，使用堆排序。取出前k个元素，建立一个小顶堆，O(k)，然后遍历剩下的n-k个元素，每个元素进堆为O(logk)，整个复杂度为O(k) + O((n-k)logk) = O(nlogk)
思路四：
分治法核心思路是把大问题分解为小问题，然后分开解决，最终解决大问题。
减治法是把大问题分解为小问题，然后只解决其中一个分支，也可以解决大问题。比如二分查找，每次只需要查找某一边，复杂度为O(logn).
这个问题也可以用减治法，称为随机选择。
利用快排的dopivot函数，将数组分为以i为中心的左大右小部分（分解问题），判断i与k的大小，可以知道k在i的哪一边。多次循环可以分出以k为中心的左大右小区域。循环次数与k大小无关，dopivot函数复杂度为O(n)，所以整个随机选择的复杂度为O(n)</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://shawling.github.io/posts/binary-tree/</link>
      <pubDate>Thu, 28 Jan 2021 11:37:27 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/binary-tree/</guid>
      <description>完全二叉树存储在数组中时，所有元素可以根据根元素的下标地址计算得出，所以完全二叉树适合用数组存储
堆就是一种完全二叉树，最常用的存储方式就是数组
二叉树的遍历
前中后序遍历指的是根节点的遍历顺序，左节点一定在右节点之前遍历
二叉查找树
利用二叉树的结构，并赋予左小右大的特性来储存数据
查找
递归思路查找
插入
递归思路找到父节点，并插入为叶子节点
删除
没有子节点：直接删除
有一个子节点：将父节点指向自己的指针指向子节点
有两个或子节点：找到右子树中最小的节点（必没有左节点），将这个节点删除并替换自己，这个节点的删除操作参见上两种方法
平衡二叉查找树
二叉查找树最好状态是一颗完全二叉树，最坏状态是一个链表
平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。
平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。
平衡二叉查找树与散列表
 散列表不支持按顺序区间遍历，需要额外数据结构（链表等）支持 散列表由于散列冲突的存在，装载因子不能太大，会浪费一定空间。同时散列冲突会导致散列表的性能不稳定 散列表在扩容时需要开辟新空间，转移新旧数据等，查找性能与空间使用都不太稳定  红黑树
红黑树是最常用的平衡二叉查找树。他通过几个定义，保证了自己的最大高度是2*logn
 根节点是黑色的； 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据； 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的； 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；  由来： 解决二叉查找树性能退化的问题
特性：近似平衡，最大高度是O(logn)
适用场景：动态插入删除查找的场景，同时对性能稳定性要求高
缺点：实现比较复杂，可以用跳表替代</description>
    </item>
    
    <item>
      <title>我来啦</title>
      <link>https://shawling.github.io/posts/my-first-post/</link>
      <pubDate>Fri, 15 Jan 2021 11:48:17 +0800</pubDate>
      
      <guid>https://shawling.github.io/posts/my-first-post/</guid>
      <description>😅</description>
    </item>
    
  </channel>
</rss>
